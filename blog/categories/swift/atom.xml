<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Adventures In iLand]]></title>
  <link href="http://verticon.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://verticon.github.io/"/>
  <updated>2021-01-14T16:55:55-05:00</updated>
  <id>http://verticon.github.io/</id>
  <author>
    <name><![CDATA[Verticon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Capture Lists Rock]]></title>
    <link href="http://verticon.github.io/blog/2020/11/17/swift-capture-lists/"/>
    <updated>2020-11-17T14:55:19-04:00</updated>
    <id>http://verticon.github.io/blog/2020/11/17/swift-capture-lists</id>
    <content type="html"><![CDATA[<p>Closures capture (enclose) their environment. This is to say that a closure is able to access any variable that is visible from the context wherein the closure is defined. This remains true even if the closure is passed into another environment where from those variables are not visible (ex. a function defined in a different file). Capture lists provide a syntax for modifying the manner whereby a closure captures its environment.</p>

<!-- more -->

<h2 id="first-a-look-at-closures-without-capture-lists">First a Look at Closures Without Capture Lists</h2>

<p>In order to understand capture lists we must first understand how a closure functions when no capture list has been declared. In the absence of a capture list, a closure accesses its environment’s variables through the use of pointers.[Caveat: I am using the word “pointer” because it works very well when discussing closure behavior. However, I have some uncertainty about whether or not it is the 100% technically correct term]. This is best illustrated with an example:</p>

<p><div><script src='https://gist.github.com/4399100df8182eda310903fab4a6be43.js?file=ExampleOne.swift'></script>
<noscript><pre><code>var i = 1
let closure = { print(i) }
closure()   // prints 1
i = 2
closure()   // prints 2
</code></pre></noscript></div>
</p>

<p>Note that the variable <em>name</em> has the value “verticon” at the time that the closure is defined. But if the value is changed and then the closure is again executed the new value is printed. The closure has a pointer to the variable and will always print its current value. Let’s do the same thing with a struct:</p>

<p><div><script src='https://gist.github.com/4399100df8182eda310903fab4a6be43.js?file=ExampleTwo.swift'></script>
<noscript><pre><code>struct Name {
    let value: String
}
var my = Name(value: &quot;verticon&quot;)
let closure = { print(my.value) }
closure()   // prints verticon
my = Name(value: &quot;morpheus&quot;)
closure()   // prints morpheus

</code></pre></noscript></div>
</p>

<p>Again the closure has a pointer to the variable and will always print its current value.</p>

<p>The first two examples used value types. Let’s see what happens with a reference type:</p>

<p><div><script src='https://gist.github.com/4399100df8182eda310903fab4a6be43.js?file=ExampleThree.swift'></script>
<noscript><pre><code>class Name {
    var value : String
    init(value : String) {
        self.value = value
    }
}

var ref = Name(value: &quot;verticon&quot;)
let closure = { print(ref.value) }

closure() // prints verticon

ref = Name(value: &quot;morpheus&quot;)

closure() // prints morpheus

</code></pre></noscript></div>
</p>

<p>This example takes a bit more thought. The variable <em>name</em> refers to a Name type. Its value is a reference to an actual instance of the Name type. The closure has a pointer to <em>name</em>. When the closure dereferences that pointer it obtains <em>name’s</em> current value, a references to a Name instance. Just as in the previous two examples the closure always prints the current value of the variable.</p>

<h2 id="on-to-capture-lists">On To Capture Lists</h2>

<p>The syntax of a capture list is [variable1, variable2, …, variableN] The comma separated list of items inside of the square brackets are the names of variables from the environment - those variables will have their capture semantics altered. Here are some examples of closure declarations that specify a capture list:</p>

<pre><code>let value = 1
let closure1 = { [value] in return value }
let closure2 = { [value] (i: Int) in return i * value }
let closure3 = { [value] (i: Int) -&gt; Bool in return i &gt; value }
</code></pre>

<p>A capture list must occur at the start of a closure declaration and the closure declaration must, at a minimum, include the <code>in</code> keyword. Strangely, the following declaration compiles but the capture semantics of the variable <em>value</em> are not altered:</p>

<pre><code>let closure1 = { [value]
    return value }
</code></pre>

<p>The following, however, works as expected:</p>

<pre><code>let closure1 = { [value] in
    return value }
</code></pre>

<p>It feels like a compiler bug. I am using Swift 3.1</p>

<p>So what do we mean when we say that the variables specified in the capture list have their capture semantics altered? We mean this: the closure will no longer capture a pointer to the variable; instead it will capture the value that the variable has at the time that the closure is created. If the variable’s value is subsequently changed then the closure will continue to execute with the old value. To see this in action let’s revisit our previous examples, modified by specifying a capture list.</p>

<p><div><script src='https://gist.github.com/4399100df8182eda310903fab4a6be43.js?file=ExampleOneRevisited.swift'></script>
<noscript><pre><code>var i = 1
let closure = { [i] in print(i) }
closure()   // prints 1
i = 2
closure()   // prints 1</code></pre></noscript></div>
</p>

<p><div><script src='https://gist.github.com/4399100df8182eda310903fab4a6be43.js?file=ExampleTwoRevisited.swift'></script>
<noscript><pre><code>struct Name {
    let value: String
}

var my = Name(value: &quot;verticon&quot;)
let closure = { [my] in print(my.value) }
closure()   // prints verticon
my = Name(value: &quot;morpheus&quot;)
closure()   // prints verticon</code></pre></noscript></div>
</p>

<p><div><script src='https://gist.github.com/4399100df8182eda310903fab4a6be43.js?file=ExampleThreeRevisited.swift'></script>
<noscript><pre><code>class Name : CustomStringConvertible {
    var value : String
    init(value : String) {
        self.value = value
    }
    var description: String {
        return value
    }
}

var ref = Name(value: &quot;verticon&quot;)
let closure = { [ref] in print(ref) }
closure() // prints verticon
ref = Name(value: &quot;morpheus&quot;)
closure() // prints verticon</code></pre></noscript></div>
</p>

<p>In each case the value printed by the closure does not change when the value of the variable is changed. This is because the closure has captured the variable’s value instead of a pointer to it. Pretty straight forward, yes?</p>

<h2 id="but-wait-theres-more">But Wait, There’s More</h2>

<p>Something to realize about closures is that they are reference type objects. This means that they, just like class objects, remain in existence until their reference count goes to zero. And, <em>this is important</em>, any objects referenced by the closure cannot be deallocated as long as the closure remains in existence. Unless, that is, we take steps to prevent that from occurring - more about that as we go along.</p>

<p>Let’s introduce the code that we will use to explore the object retention behavior of closures. [Note: This code is ready to run in a playground]</p>

<p><div><script src='https://gist.github.com/4399100df8182eda310903fab4a6be43.js?file=ReferenceRetention.swift'></script>
<noscript><pre><code>import Foundation
import PlaygroundSupport

class Executor {

    typealias Closure = () -&gt; Void
    private var closure: Closure?
    private var counter = 0

    init(closure: @escaping Closure) {
        self.closure = closure

        let timer = Timer(timeInterval: 1.00, target: self, selector: #selector(execute), userInfo: nil, repeats: true)
        RunLoop.main.add(timer, forMode: RunLoopMode.commonModes)
    }
    
    @objc private func execute() {
        if let closure = closure {
            closure()
            counter += 1
            if counter == 5 { self.closure = nil }
        }
    }
}

class Closure {

    class Name : CustomStringConvertible {
        let name: String
        init(_ name: String) { self.name = name }
        deinit { print(&quot;Name deallocated: \(name)&quot;) }
        var description: String { return name }
    }

    var name: Name

    init(name: Name) {
        self.name = name

        let closure = { [name = name.name] in print(&quot;\(name)&#39;s closure executed&quot;) }
        _ = Executor(closure: closure)
    }
    
    deinit { print(&quot;Closure deallocated: \(name)&quot;) }
}

do {
    let closure = Closure(name: Closure.Name(&quot;Verticon&quot;))
}

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre></noscript></div>
</p>

<p>The Creator class creates a closure and hands it to an Executor for execution. We’ll be using a Creator instance to look into the retention consequences of the closure accessing the Creator’s members. The Creator contains several versions of the closure which we will be commenting/uncommenting in order to observe the differences</p>

<p>The Executor class stores a closure, thus keeping it “alive”. It uses a timer to periodically execute the closure, continuing to do so until “something” (such as our Controller) sets the closure to nil.</p>

<p>The Controller class sets things into motion by instantiating a Creator. It also presents a UI with two buttons: one is used to set the Creator variable to nil; the other is used to set the Executor’s closure variable to nil.</p>

<h4 id="closure-version-1">Closure version 1</h4>

<pre><code>let closure = { log("\n\(name)'s closure executed") } // Version 1
</code></pre>

<p>Here the value of the initializer’s <code>nameArg</code> argument is captured. This has no retention consequences and hence the Creator and its Name are immediately deallocated when the deallocate creator button is pressed. The closure “lives on” and continues to execute until the deallocate closure button is pressed.</p>

<pre><code>Verticon's closure executed 2017-10-04 20:17:04 +0000

Verticon's closure executed 2017-10-04 20:17:06 +0000

Deallocate creator button pressed 2017-10-04 20:17:07 +0000
Creator deallocated 2017-10-04 20:17:07 +0000
Name deallocated 2017-10-04 20:17:07 +0000

Verticon's closure executed 2017-10-04 20:17:08 +0000

Verticon's closure executed 2017-10-04 20:17:10 +0000

Deallocate closure button pressed 2017-10-04 20:17:11 +0000
Closure deallocated 2017-10-04 20:17:11 +0000
</code></pre>

<h4 id="closure-version-2">Closure version 2</h4>

<pre><code>  let closure = { [name = self.storedName.name] in log("\n\(name)'s closure executed") } // Version 2
</code></pre>

<p>Here we’ve introduced a new capture list syntax. It turns out that a capture list allows us to declare new variables for use by the closure. Here we’ve created the <code>name</code> variable so that the closure can print the name without having to reference the Creator or Name class instances. The results are exactly the same as for version 1</p>

<h4 id="closure-version-3">Closure version 3</h4>

<p>let closure = { [name = self.storedName] in log(“\n(name)’s closure executed”) } // Version 3</p>

<p>This time the closure is referencing the storeName instance [we are again declaring a local variable so that the closure will not need to reference <code>self</code>]. This results in the deallocation of the Name instance being delayed until the closure is deallocated.</p>

<pre><code>Verticon's closure executed 2017-10-04 20:30:28 +0000

Verticon's closure executed 2017-10-04 20:30:30 +0000

Deallocate creator button pressed 2017-10-04 20:30:31 +0000
Creator deallocated 2017-10-04 20:30:31 +0000

Verticon's closure executed 2017-10-04 20:30:32 +0000

Verticon's closure executed 2017-10-04 20:30:34 +0000

Deallocate closure button pressed 2017-10-04 20:30:35 +0000
Closure deallocated 2017-10-04 20:30:35 +0000
Name deallocated 2017-10-04 20:30:35 +0000
</code></pre>

<h4 id="closure-version-4">Closure version 4</h4>

<pre><code>let closure = { log("\n\(self.storedName)'s closure executed") } // Version 4
</code></pre>

<p>This time the closure is referencing both the Name and Creator instances resulting in both deallocations being delayed until the the closure is deallocated.</p>

<p>[An ancillary inquiry: In version 4, what has the closure captured? A pointer to self? If yes then what is it about capturing a pointer to a reference variable that causes the reference’s count to be incremented? These thoughts led to my initial caveat regarding the use of the word “pointer”.]</p>

<pre><code>Verticon's closure executed 2017-10-04 20:35:39 +0000

Verticon's closure executed 2017-10-04 20:35:41 +0000

Deallocate creator button pressed 2017-10-04 20:35:42 +0000

Verticon's closure executed 2017-10-04 20:35:43 +0000

Verticon's closure executed 2017-10-04 20:35:45 +0000

Deallocate closure button pressed 2017-10-04 20:35:46 +0000
Closure deallocated 2017-10-04 20:35:46 +0000
Creator deallocated 2017-10-04 20:35:46 +0000
Name deallocated 2017-10-04 20:35:46 +0000
</code></pre>

<h2 id="fine-but-so-what">Fine But So What?</h2>

<p>Okay, we’ve seen that a closure can cause an object’s reference count to increase but why do we care? Well, in the case of the Creator/Executor/Controller example the Controller can access the variable that holds the closure reference and nil it when needed, but what if this is not the case? What if we release the closure <em>out into the wild</em> by invoking a function such as this:</p>

<pre><code>func doSomething(with: @escaping () -&gt; Void)
</code></pre>

<p>The @escaping attribute tells us that the function is going to store the closure reference. Now the closure is <em>living out there somewhere</em> and there is nothing that we can do about. There is, however, something that we can do so that this scenario does not prevent us from deallocating the objects to which the closure refers: we can use a capture list to declare that the closure’s references are <code>weak</code>.</p>

<h4 id="closure-version-5">Closure version 5</h4>

<pre><code>let closure = { [weak self] in log("\n\(self?.storedName.name ?? "NoName")'s closure executed") } // Version 5
</code></pre>

<p>Now when the Deallocate Creator button is pressed the Creator and the Name are immediately deallocated even though the closure is still alive.</p>

<pre><code>Verticon's closure executed 2017-10-05 16:22:30 +0000

Verticon's closure executed 2017-10-05 16:22:32 +0000

Deallocate creator button pressed 2017-10-05 16:22:33 +0000
Creator deallocated 2017-10-05 16:22:33 +0000
Name deallocated 2017-10-05 16:22:33 +0000

NoName's closure executed 2017-10-05 16:22:34 +0000

NoName's closure executed 2017-10-05 16:22:36 +0000

Deallocate closure button pressed 2017-10-05 16:22:38 +0000
Closure deallocated 2017-10-05 16:22:38 +0000
</code></pre>

<p>There is one other option that we have for preventing a closure from holding a strong reference: we can use the <code>unowned</code> attribute instead of the <code>weak</code> attribute. The <code>unowned</code> attribute has the advantage of not being checked for nil (rather like an implicitly unwrapped optional) and therefor results in faster executing code (which might matter). However, in order to use <code>unowned</code> we must be certain that our code meets a certain criteria: we must guarantee that the closure will never again be executed after the object being referenced has been deallocated. Like <code>weak</code>, <code>unowned</code> will allow the object to be deallocated but like an implicitly unwrapped optional it will cause the program to trap if it is used after being set to nil (the system sets weak and unowned references to nil when the object being referenced is deallocated).</p>

<h4 id="closure-version-6">Closure version 6</h4>

<pre><code>let closure = { [unowned self] in log("\n\(self.storedName)'s closure executed") } // Version 6
</code></pre>

<p>When the Deallocate Creator button is pressed the program crashes. [In a playground this is evidenced by the Controller disappearing from the Timeline Assistant Editor and a home screen appearing] However, if we first press the Deallocate Closure button then all is well. Here is a less contrived example wherein <code>unowned</code> is used successfully:</p>

<p><div><script src='https://gist.github.com/4399100df8182eda310903fab4a6be43.js?file=UnownedSelf.swift'></script>
<noscript><pre><code>protocol Notifier {
    typealias Client = (Data) -&gt; Void
    typealias Token = Any
    
    func register(client: Client) -&gt; Token
    
    // The previously registered Consumer is discarded
    func deregister(token: Token)
}

class Registrant {
    private let name: String
    private let notifier: Notifier
    private var token: Notifier.Token? = nil
    
    init(name: String, notifier: Notifier) {
        self.name = name
        self.notifier = notifier
        
        token = notifier.register { [unowned self] (data: Data) in
            print(&quot;\(self.name) has been notified: \(data)&quot;)
        }
    }
    
    deinit {
        if let token = token {
            notifier.deregister(token: token)
        }
    }
}
</code></pre></noscript></div>
</p>

<h2 id="conclusion">Conclusion</h2>

<p>Alright, there we have it. When we write closures we can capture variables with confidence.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Persisting Structs in Swift]]></title>
    <link href="http://verticon.github.io/blog/2020/11/11/persisting-structs-in-swift/"/>
    <updated>2020-11-11T17:20:44-04:00</updated>
    <id>http://verticon.github.io/blog/2020/11/11/persisting-structs-in-swift</id>
    <content type="html"><![CDATA[<p>My journey through iLand recently brought me to the place whereat I needed to persist the data records being created by my application. My first thought was Core Data. But then <a href="http://nshipster.com/nscoding/">NSHipster</a> helped me to realize that NSCoding would be a better choice for my situation. Great! Off I go. But darn! The NSCoding protocol is restricted to class types and I am using structs (and want them for their value semantics). What to do? After some looking around, <a href="http://redqueencoder.com/property-lists-and-user-defaults-in-swift/">The Red Queen Coder</a> (TL;DR sorry Red Queen) came to my rescue. I liked the Red Queen’s approach but was not very satisfied with the implementation. I would like to present the results of my tweaking and polishing.</p>

<!-- more -->

<p>I will start out by showing the code that will be used to accomplish the persisting of structs. Then I will show an example that uses that code.</p>

<h2 id="implementation">Implementation</h2>

<h3 id="the-encodable-protocol">The Encodable Protocol</h3>
<p>Types (such as structs) announce their encodability (which will allow them to be persisted) by adopting the Encodable protocol. The encode method is used to store the properties of an instance of the type into a dictionary. The initializer is used to reconstruct an instance of the type from that dictionary. The initializer is failable because there is no guarantee that the dictionary that is passed in was actually encoded by the type. The initializer’s parameter is optional so as to allow cleaner code at the call site. As we will see, it is these dictionaries that are persisted.</p>

<pre><code>public protocol Encodable {
    typealias Properties = Dictionary&lt;String, Any&gt;
    func encode() -&gt; Properties
    init?(_ properties: Properties?)
}
</code></pre>

<h3 id="helper-extensions-on-array">Helper Extensions on Array</h3>
<p>It will often occur that we have a array of objects to be encoded.<br />
These extensions will make the usage at the call site a bit cleaner; allowing us to write <code>myArray.encode()</code> and <code>myArray.decode()</code>.</p>

<pre><code>extension Array where Element : Encodable {
    public func encode() -&gt; [Encodable.Properties] {
        return map{ $0.encode() }
    }
}

extension Array where Element == Encodable.Properties {
    public func decode&lt;T:Encodable&gt;(type: T.Type) -&gt; [T] {
        return flatMap{ T($0) }
    }
}
</code></pre>

<h3 id="persisting-to-user-defaults">Persisting to User Defaults</h3>
<p>These top level functions will save/load arrays of Encodable objects to/from User Defaults. Note that loadFromFile’s type parameter specifies the type of the objects to be instantiated from each of the Encodable.Properties (i.e Dictionaries)</p>

<pre><code>public func saveToUserDefaults&lt;T:Encodable&gt;(_ objects: [T], withKey key: String) {
    UserDefaults.standard.set(objects.encode(), forKey: key)
}

public func loadFromUserDefaults&lt;T:Encodable&gt;(type: T.Type, withKey key: String) -&gt; [T]? {
    return (UserDefaults.standard.array(forKey: key) as? [Encodable.Properties])?.decode(type: T.self)
}
</code></pre>

<h3 id="persisting-to-a-file">Persisting to a File</h3>
<p>These top level functions will save/load arrays of Encodable objects to/from a file in the document directory. Note that at this point we are able to use NSKeyedArchiver and NSKeyedUnarchiver because all of the items in the dictionaries are types that are known to NSKeyedArchiver and NSKeyedUnarchiver (i.e. Int, String, Double, etc).</p>

<pre><code>public func saveToFile&lt;T:Encodable&gt;(_ values: [T], withName name: String) -&gt; Bool {
    do {
        let data = NSKeyedArchiver.archivedData(withRootObject: values.encode())
        try data.write(to: getUrl(forName: name), options: .atomic)
        return true
    } catch {
        print(error)
    }
    return false
}

public func loadFromFile&lt;T:Encodable&gt;(type: T.Type, withName name: String) -&gt; [T]? {
    do {
        let data = try Data(contentsOf: getUrl(forName: name))
        if let encoded = NSKeyedUnarchiver.unarchiveObject(with: data) as? [Encodable.Properties] {
            return encoded.decode(type: type)
        }
    } catch {
        print(error)
    }
    return nil
}

private func getUrl(forName: String) -&gt; URL {
    return try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false).appendingPathComponent(forName)
}
</code></pre>

<h2 id="a-persistence-example">A Persistence Example</h2>

<h3 id="the-encodable-type">The Encodable Type</h3>
<p>Adopting the Encodable protocol is simple: <code>encode</code> writes the properties to a dictionary, <code>init</code> restores them from a dictionary.</p>

<pre><code>struct MyData {
    let int: Int
    let double: Double
    let string: String
    let bool: Bool
    let date: Date
    let blob: Data
}

extension MyData: Encodable {

    func encode() -&gt; Properties {
        return ["int": int, "double": double, "string": string, "bool": bool, "date": date, "blob": blob, ]
    }

    init?(_ properties: Properties?) {
        guard let properties = properties else { return nil }

        if let int = properties["int"] as? Int,
           let double = properties["double"] as? Double,
           let string = properties["string"] as? String,
           let bool = properties["bool"] as? Bool,
           let date = properties["date"] as? Date,
           let blob = properties["blob"] as? Data {
               self.int = int
               self.double = double
               self.string = string
               self.bool = bool
               self.date = date
               self.blob = blob
        } else {
            return nil
        }
    }
}
</code></pre>

<h3 id="using-the-persistence-functions">Using the Persistence Functions</h3>
<p>And, finally here is how instances of MyData can be persisted.</p>

<pre><code>let myData = [MyData(int: 1, double: 1.0, string: "One", bool: true, date: Date(), blob: Data(bytes: [1,2,3,4,5,6,7,8])),
              MyData(int: 2, double: 2.0, string: "Two", bool: false, date: Date(), blob: Data(bytes: [9,10,11,12]))]


print("Original:")
myData.forEach{ print("\t", $0) }
// Prints:
// Original:
//     MyData(int: 1, double: 1.0, string: "One", bool: true, date: 2017-04-04 16:04:36 +0000, blob: 8 bytes)
//     MyData(int: 2, double: 2.0, string: "Two", bool: false, date: 2017-04-04 16:04:36 +0000, blob: 4 bytes)


print("\nEncode =&gt; Decode:")
myData.encode().decode(type: MyData.self).forEach{ print("\t", $0) }
// Prints:
// Encode =&gt; Decode:
//     MyData(int: 1, double: 1.0, string: "One", bool: true, date: 2017-04-04 16:04:36 +0000, blob: 8 bytes)
//     MyData(int: 2, double: 2.0, string: "Two", bool: false, date: 2017-04-04 16:04:36 +0000, blob: 4 bytes)


print("\nUser Defaults: Save =&gt; Load")
let key = "MyData"
saveToUserDefaults(myData, withKey: key)
loadFromUserDefaults(type: MyData.self, withKey: key)?.forEach{ print("\t", $0) }
// Prints:
// User Defaults: Save =&gt; Load
//     MyData(int: 1, double: 1.0, string: "One", bool: true, date: 2017-04-04 16:04:36 +0000, blob: 8 bytes)
//     MyData(int: 2, double: 2.0, string: "Two", bool: false, date: 2017-04-04 16:04:36 +0000, blob: 4 bytes)


print("\nFile: Save =&gt; Load")
let fileName = "MyData.dat"
if saveToFile(myData, withName: fileName) {
    loadFromFile(type: MyData.self, withName: fileName)?.forEach{ print("\t", $0) }
}
else {
    print("Cannot save to \(fileName)")
}
// Prints:
// File: Save =&gt; Load
//     MyData(int: 1, double: 1.0, string: "One", bool: true, date:    2017-04-04 16:04:36 +0000, blob: 8 bytes)
//     MyData(int: 2, double: 2.0, string: "Two", bool: false, date: 2017-04-04 16:04:36 +0000, blob: 4 bytes)
</code></pre>

<h3 id="conclusion">Conclusion</h3>

<p>This has worked great for me. I have the put the implementation into my toolbox framework. I have coded my application’s data structs similarly to the MyData example. And, voila! When my application restarts it is able to recover its data.</p>

<p>You can download a playground that contains all of the above code <a href="https://github.com/verticon/PersistingStructsInSwift">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What the Heck Is Type Erasure and Why Should We Care?]]></title>
    <link href="http://verticon.github.io/blog/2020/10/27/what-the-heck-is-type-erasure/"/>
    <updated>2020-10-27T17:14:59-05:00</updated>
    <id>http://verticon.github.io/blog/2020/10/27/what-the-heck-is-type-erasure</id>
    <content type="html"><![CDATA[<p>We are all unique individuals whose minds process and organize information in different ways, and whose communication styles reflect that internal organization. When I first encountered the words <strong>Type Erasure</strong> I thought: <em>“Oh, some cool swifty thing. I’d better find out about it”</em>. So, I started googling and reading. But, time and again, I came up short. Even though I (mostly) understood what I had read, my understanding felt incomplete. There seemed to be something missing, as though the author had not made some essential concept clear. However, I persevered and now I get it. So for this, my first ever blog post, I’m going to take a shot at explaining type erasure. Maybe it will help someone else who thinks differently.</p>

<!-- more -->

<h2 id="generic-protocols-have-some-limitations">Generic Protocols Have Some Limitations</h2>

<p>Swift’s implementation of generic protocols comes with some limitations. We cannot use generic protocols in all of the ways that we are accustomed to using regular protocols. Let’s have a look. Here are some ways in which we normally use a protocol:</p>

<p><div><script src='https://gist.github.com/0912a5667b684b0b6894ab021f59e6d5.js?file=RegularProtocol.swift'></script>
<noscript><pre><code>protocol MyProtocol {} // Regular protocols
class MyAdopter : MyProtocol {} // can be adopted,
func myGenericFunction&lt;T : MyProtocol&gt;(arg: T) {} // or used to constrain generic type parameters
var myVariable: MyProtocol // or used to specify the type of a variable,
func myFuction(arg: MyProtocol) {} // function parameter,
func myFuction() -&gt; MyProtocol { return MyAdopter() } // or function result.
</code></pre></noscript></div>
<br />
<a href="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/RegularProtocol.png"><img src="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/RegularProtocol.png"></a></p>

<p>As you can see in the REPL screen shot, the compiler is happy with the code. However, when we use a generic protocol the results are different:</p>

<p><div><script src='https://gist.github.com/0912a5667b684b0b6894ab021f59e6d5.js?file=GenericProtocol.swift'></script>
<noscript><pre><code>protocol MyProtocol { associatedtype MyType } // Generic protocols
class MyAdopter : MyProtocol { typealias MyType = String } // can be adopted,
func myGenericFunction&lt;T : MyProtocol&gt;(arg: T) {} // or used to constrain generic type parameters.
// The following three statements will not compile.
var myVariable: MyProtocol // But cannot be used to specify the type of a variable,
func myFuction(arg: MyProtocol) {} // function parameter,
func myFuction() -&gt; MyProtocol { return MyAdopter() } // or function result.
</code></pre></noscript></div>
<br />
<a href="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/GenericProtocol.png"><img class="center" src="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/GenericProtocol.png"></a></p>

<p>Now we have the infamous <em>“error: protocol ‘MyProtocol’ can only be used as a generic constraint because it has Self or associated type requirements”</em> compiler error on lines 4, 5, &amp; 6. We are not allowed to use a generic protocol as a type specfier. Why?</p>

<p>Well, from the compiler’s perspective the issue is type safety. The compiler does not know the type of the associated type and therefore cannot enforce type safety. From the swift development team’s perspective: I do not know what challenges they faced while creating generic protocols but I think they decided that the benefits of generic protocols as they currently stand are sufficiently compelling (hmmmm … a good topic for another post) to justify their incorporation into the language in spite of the limitations.</p>

<h2 id="an-example-wherein-we-would-like-to-use-generic-protocols-to-specify-types">An Example Wherein We Would Like To Use Generic Protocols To Specify Types</h2>

<p><div><script src='https://gist.github.com/0912a5667b684b0b6894ab021f59e6d5.js?file=SoldiersAndWeapons.swift'></script>
<noscript><pre><code>// Soldiers use their weapons to fight

protocol Weapon {
    func fire()
}

protocol Soldier {
    associatedtype W: Weapon

    var weapon: W { get }
    
    func fight()
}

extension Soldier {
    func fight() {
        weapon.fire()
    }
}

// Here are some Weapons

struct Rifle : Weapon {
    func fire() { print(&quot;Bullets away!&quot;) }
}

struct Rocket : Weapon {
    func fire() { print(&quot;Rockets away!&quot;) }
}

struct GrenadeLauncher : Weapon {
    func fire() { print(&quot;Grernades away!&quot;) }
}


// Here are some Soldiers

struct Sniper : Soldier {
    var weapon = Rifle()
}

struct Infantryman : Soldier {
    var weapon = Rifle()
}

struct Artillaryman : Soldier {
    var weapon = Rocket()
}

struct Grenadier : Soldier {
    var weapon = GrenadeLauncher()
}
</code></pre></noscript></div>
</p>

<p>We can create an army of infantry men, or grenadiers, or etc. But we cannot create an army of soldiers.</p>

<p><div><script src='https://gist.github.com/0912a5667b684b0b6894ab021f59e6d5.js?file=ProblematicArmy.swift'></script>
<noscript><pre><code>// Let&#39;s create an army of soldiers
//
// Error: The compiler will not let us use Soldier as a type
class Army {
    var soldiers = [Soldier]()
    
    func join(soldier: Soldier) {
        soldiers.append(soldier)
    }
    
    func makeWar() {
        for soldier in soldiers { soldier.fight() }
    }
}
</code></pre></noscript></div>
<br />
<a href="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/ProblematicArmy.png"><img class="center" src="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/ProblematicArmy.png"></a></p>

<h2 id="type-erasure-to-the-rescue">Type Erasure To The Rescue</h2>

<p>Type Erasure is a coding technique whereby we can work around the type specification limitation of generic protocols. For any given generic protocol, let’s call it MyGenericProtocol, we will define an <em>erasing</em> type, let’s call it MyTypeEraser. MyTypeEraser will adopt MyGenericProtocol and will be used as a substitute for MyGenericProtocol when specifying types: wherever we would have liked to use MyGenericProtocol to specify a type, we will instead use MyTypeEraser. MyTypeEraser will give us all of the benefits of MyGenericProtocol without the limitation. Let’s see how this works.</p>

<p>In the case of our Army example, the generic protocol that we are dealing with is Soldier. We will name our type eraser AnySoldier. [Note that the prefix <code>Any</code> followed by the name of the generic protocol is a naming convention that Apple follows in the swift standard library when type erasing is employed: <a href="https://developer.apple.com/reference/swift/anysequence">AnySequence</a>, <a href="https://developer.apple.com/reference/swift/anycollection">AnyCollection</a>, etc.] An AnySoldier will be initialized using an instance of some other Soldier adopting type (Sniper, Infantryman, etc.). The AnySoldier will <em>capture</em> the actual soldier’s implementation of the Soldier protocol (you’ll soon see what we mean by capture). The AnySoldier will then be used as a standin for the actual soldier: wherever we need a Soldier adopter such as an Infantryman or a Grenadier, we will instead create and use an AnySoldier. Whenever the application accesses an AnySoldier via the Soldier protocol, the AnySoldier will forward that access to the original soldier instance. The concrete AnySoldier type will effectively behave like a Soldier protocol because nothing other than the protocol’s interface will be exposed. AnySoldier can be used without the compiler having any knowledge of the original instance’s type; that original type <strong>will have been erased</strong>. This will all become more clear as we proceed.</p>

<h2 id="anysoldier-first-pass">AnySoldier: First Pass</h2>

<p>Let’s start developing AnySoldier. In order for AnySoldier to adopt the Soldier protocol it must specify the type of Weapon. How shall we handle this? Well, we could make AnySoldier generic with regard to the type of Weapon.</p>

<p><div><script src='https://gist.github.com/0912a5667b684b0b6894ab021f59e6d5.js?file=AnySoldierFirstPass.swift'></script>
<noscript><pre><code>struct AnySoldier&lt;W: Weapon&gt; : Soldier {
    var weapon: W
    
    init&lt;S: Soldier&gt;(soldier: S) where S.W == W {
        weapon = soldier.weapon
    }

    func fight() {}
}

class Army {
    var soldiers = [AnySoldier&lt;Rifle&gt;]()
    
    func join(soldier: AnySoldier&lt;Rifle&gt;) {
        soldiers.append(soldier)
    }
    
    func makeWar() {
        for soldier in soldiers { soldier.fight() }
    }
}

let army = Army()
army.join(soldier: AnySoldier(soldier: Sniper()))
army.join(soldier: AnySoldier(soldier: Infantryman()))
army.join(soldier: AnySoldier(soldier: Grenadier()))
</code></pre></noscript></div>
<br />
<a href="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/AnySoldierFirstPass.png"><img class="center" src="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/AnySoldierFirstPass.png"></a></p>

<p>Well, that’s not what we want. We weren’t able to add a Grenadier to the army. We can create an army of any type of soldier as long as they all use the same type of Weapon (in this case Rifle). We’ve moved our issue from the Soldier to the Weapon. What can we do?</p>

<h2 id="anysoldier-second-pass">AnySoldier: Second Pass</h2>

<p>How about if we type erase Weapon as well? Let’s create an AnyWeapon.</p>

<p><div><script src='https://gist.github.com/0912a5667b684b0b6894ab021f59e6d5.js?file=AnySoldierSecondPass.swift'></script>
<noscript><pre><code>struct AnyWeapon : Weapon {
    
    init(weapon: Weapon) {}
    
    func fire(wielder: String) {}
}

struct AnySoldier : Soldier {
    var weapon: AnyWeapon
    
    init&lt;S: Soldier&gt;(soldier: S) {
        weapon = AnyWeapon(weapon: soldier.weapon)
    }
    
    func fight() {}
}

class Army {
    var soldiers = [AnySoldier]()
    
    func join(soldier: AnySoldier) {
        soldiers.append(soldier)
    }
    
    func makeWar() {
        for soldier in soldiers { soldier.fight() }
    }
}

let army = Army()
army.join(soldier: AnySoldier(soldier: Sniper()))
army.join(soldier: AnySoldier(soldier: Infantryman()))
army.join(soldier: AnySoldier(soldier: Grenadier()))
army.join(soldier: AnySoldier(soldier: Artillaryman()))
army.makeWar()
</code></pre></noscript></div>
<br />
<a href="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/AnySoldierSecondPass.png"><img class="center" src="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/AnySoldierSecondPass.png"></a></p>

<p>There we go; the compiler is happy. We can create an army and populate it with any and all types of Soldiers. Great! But wait a minute: the weapons aren’t firing (i.e. the print statements are not coming to the terminal). What is going on?</p>

<h2 id="anysoldier-final-solution">AnySoldier: Final Solution</h2>

<p>Well, remember that we said: “AnySoldier will <em>capture</em> the actual soldier’s implementation of the Soldier protocol”. We haven’t yet implemented the captures. Time for the magic sauce.</p>

<p><div><script src='https://gist.github.com/0912a5667b684b0b6894ab021f59e6d5.js?file=AnySoldierFinalSolution.swift'></script>
<noscript><pre><code>struct AnyWeapon : Weapon {
    private let _fire: (String) -&gt; Void
    
    init(weapon: Weapon) {
        _fire = weapon.fire
    }
    
    func fire(wielder: String) {
        _fire(wielder)
    }
}

struct AnySoldier : Soldier {
    var weapon: AnyWeapon
    private let _fight: () -&gt; Void
    
    init&lt;S: Soldier&gt;(soldier: S) {
        weapon = AnyWeapon(weapon: soldier.weapon)
        _fight = soldier.fight
    }
    
    func fight() {
        _fight()
    }
}

class Army {
    var soldiers = [AnySoldier]()
    
    func join(soldier: AnySoldier) {
        soldiers.append(soldier)
    }
    
    func makeWar() {
        for soldier in soldiers { soldier.fight() }
    }
}

let army = Army()
army.join(soldier: AnySoldier(soldier: Sniper()))
army.join(soldier: AnySoldier(soldier: Infantryman()))
army.join(soldier: AnySoldier(soldier: Grenadier()))
army.join(soldier: AnySoldier(soldier: Artillaryman()))
army.makeWar()
</code></pre></noscript></div>
<br />
<a href="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/AnySoldierFinalSolution.png"><img class="center" src="/images/blog/2017/01/24/what-the-heck-is-type-erasure-and-why-should-we-care/AnySoldierFinalSolution.png"></a></p>

<p>Voila! All weapons are firing. Let there be war.</p>

<h2 id="wrapping-it-up">Wrapping It Up</h2>

<p>An AnySoldier is able to <em>assume the Soldier identity</em> of any adopter of the Soldier protocol (Sniper, Infantryman, Grenadier, or Artillaryman). The AnySoldier accomplishes this without any reference to the original type. That original type has dissappeared from view; <strong>it has been erased</strong>. With AnySoldier at our disposal we can write code that is equivalent to what we would have written were we able to use Soldier to specify types. AFAIK there is no functional difference between specifying types with AnySoldier vs Soldier (given that we were allowed to). I would hazard to say that if a future swift allowed us to use generic protocols as type specifiers then a find/replace AnySoldier =&gt; Soldier would do the trick. This is why we care about type erasure.</p>

<p>There you have it. Type Erasure a la Verticon. I hope that it spoke to you. As I said, this is my first blog post. I expect to learn and to get better at it. Any feedback will be welcome. For those of you whose different way of thinking is different from mine, here are some other posts on the same topic:</p>
<ul>
  <li><a href="http://robnapier.net/erasure">Rob Napier</a></li>
  <li><a href="https://krakendev.io/blog/generic-protocols-and-their-shortcomings">Hector Matos</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
